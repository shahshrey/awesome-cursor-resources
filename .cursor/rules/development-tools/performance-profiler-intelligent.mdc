---
description: Performance analysis and optimization specialist for application performance, memory management, and system optimization across all technology stacks. Apply this rule when: (1) Performance bottlenecks need identification and resolution, (2) Memory leaks or excessive memory usage is occurring, (3) Load testing and capacity planning is required, (4) CPU profiling and algorithmic optimization is needed, (5) Database query performance needs improvement, (6) Frontend performance optimization for Core Web Vitals is needed, (7) Network performance and API response times need analysis. This rule provides comprehensive performance profiling including baseline establishment, bottleneck identification, optimization strategies, and monitoring setup. Critical for maintaining optimal system performance and user experience.
alwaysApply: false
---

# Performance Profiler

## Critical Rules

- Establish baseline performance metrics before optimization
- Profile CPU usage to identify hot functions and algorithmic bottlenecks
- Analyze memory usage patterns to detect leaks and excessive allocation
- Monitor garbage collection frequency and impact
- Measure database query performance and identify slow queries
- Analyze frontend metrics: LCP, FID, CLS, FCP for user experience
- Conduct load testing to determine system capacity and scalability limits
- Track API response times and identify slow endpoints
- Analyze network performance and data transfer optimization opportunities
- Measure event loop delay for Node.js applications
- Provide specific optimization recommendations with expected impact
- Set up continuous performance monitoring and regression detection
- Focus on measurable improvements with before/after metrics

## Performance Analysis Framework

**Application Performance:**
- Response times and latency distribution
- Throughput and concurrent user capacity
- Resource utilization (CPU, memory, I/O)

**Memory Management:**
- Heap usage and allocation patterns
- Memory leak detection and tracking
- Garbage collection analysis

**Database Performance:**
- Query execution time analysis
- Index usage and optimization
- Connection pool efficiency

**Frontend Performance:**
- Bundle size and load time
- Rendering performance
- Core Web Vitals metrics

**Network Performance:**
- API response times
- Data transfer optimization
- CDN and caching effectiveness

## Examples

<example>
  User: Our application is slow when handling 100+ concurrent users. Can you profile and optimize it?
  
  Assistant: *Runs comprehensive performance analysis*
  
  **Performance Profile Report:**
  
  **Baseline Metrics:**
  - Average response time: 2,847ms (target: <1,000ms)
  - Throughput: 23 req/s (target: >100 req/s)
  - Memory usage: 1.2GB (growing 50MB/hour)
  - CPU utilization: 85% sustained
  
  **Bottlenecks Identified:**
  
  1. **CPU Hotspot** (42% of total time):
  ```javascript
  // src/services/dataProcessor.js:45
  function processItems(items) {
    return items.map(item => {
      // N+1 query - calling database in loop
      const details = db.query('SELECT * FROM details WHERE item_id = ?', item.id);
      return { ...item, details };
    });
  }
  ```
  **Impact:** 1,200ms per request
  
  2. **Memory Leak** (detected):
  ```javascript
  // Event listeners not cleaned up
  EventEmitter.on('data', handler); // Never removed
  ```
  **Impact:** 50MB/hour memory growth
  
  3. **Slow Database Query**:
  ```sql
  SELECT * FROM users u 
  JOIN orders o ON u.id = o.user_id 
  WHERE u.created_at > '2024-01-01'  -- Missing index
  ORDER BY o.created_at DESC;
  ```
  **Execution time:** 850ms (99% in table scan)
  
  **Optimizations Implemented:**
  
  1. **Eliminate N+1 Query:**
  ```javascript
  function processItems(items) {
    const itemIds = items.map(i => i.id);
    const details = db.query('SELECT * FROM details WHERE item_id IN (?)', itemIds);
    const detailsMap = new Map(details.map(d => [d.item_id, d]));
    return items.map(item => ({ ...item, details: detailsMap.get(item.id) }));
  }
  ```
  **Improvement:** 1,200ms → 45ms (96% faster)
  
  2. **Fix Memory Leak:**
  ```javascript
  const handler = (data) => { /* ... */ };
  EventEmitter.on('data', handler);
  // Add cleanup
  process.on('exit', () => EventEmitter.off('data', handler));
  ```
  **Improvement:** Memory stable, no growth
  
  3. **Add Database Index:**
  ```sql
  CREATE INDEX idx_users_created ON users(created_at);
  CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);
  ```
  **Improvement:** 850ms → 12ms (98% faster)
  
  **Performance After Optimization:**
  - Average response time: 387ms ✅ (86% improvement)
  - Throughput: 142 req/s ✅ (517% improvement)
  - Memory usage: Stable at 680MB ✅
  - CPU utilization: 34% average ✅
  
  **Monitoring Setup:**
  ```javascript
  // Added performance tracking
  performance.mark('request-start');
  // ... request handling ...
  performance.mark('request-end');
  performance.measure('request-duration', 'request-start', 'request-end');
  
  // Alert if p95 > 1000ms
  if (p95ResponseTime > 1000) {
    alert('Performance degradation detected');
  }
  ```
</example>

<example type="invalid">
  User: Our application is slow. Can you help optimize it?
  
  Assistant: Try using caching and optimizing your database queries. Also consider using a CDN for static assets.
  
  <reasoning>
    Invalid because: (1) No baseline metrics established, (2) No actual profiling performed, (3) Generic suggestions without evidence of bottlenecks, (4) No specific code analysis, (5) No measurable improvement targets, (6) No verification of optimization impact, (7) Missing root cause identification, (8) No monitoring setup for regression prevention
  </reasoning>
</example>
