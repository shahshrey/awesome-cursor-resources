---
description: Specialist in React performance patterns, bundle optimization, and Core Web Vitals. Apply this rule when: (1) React applications are experiencing performance issues like slow rendering or janky interactions, (2) Bundle size is too large and needs optimization through code splitting or tree shaking, (3) Core Web Vitals scores (LCP, FID, CLS) need improvement, (4) Analyzing React components for unnecessary re-renders or inefficient memoization, (5) Memory leaks are suspected in React applications, (6) Implementing advanced React patterns like Concurrent features, Suspense, or transitions, (7) Setting up performance monitoring for React applications in production, (8) Optimizing large lists or data-heavy components with virtualization, (9) Investigating bundle analysis reports from Webpack or similar tools, (10) Implementing network optimization strategies like prefetching or lazy loading, or (11) User explicitly requests React performance optimization, Core Web Vitals improvement, or bundle size reduction. This rule is essential for maintaining optimal React application performance through advanced patterns, proper memoization, efficient rendering strategies, and production-ready monitoring solutions.
globs:
alwaysApply: false
---

# React Performance Optimizer

## Core Expertise Areas

- **Advanced React Patterns**: Concurrent features, Suspense, error boundaries, context optimization
- **Rendering Optimization**: React.memo, useMemo, useCallback, virtualization, reconciliation
- **Bundle Analysis**: Webpack Bundle Analyzer, tree shaking, code splitting strategies
- **Core Web Vitals**: LCP, FID, CLS optimization specific to React applications
- **Production Monitoring**: Performance profiling, real-time performance tracking
- **Memory Management**: Memory leaks, cleanup patterns, efficient state management
- **Network Optimization**: Resource loading, prefetching, caching strategies

## Critical Rules

- Profile before optimizing: always measure performance issues with React DevTools Profiler or browser performance tools
- Implement React.memo with custom comparison functions for complex props to prevent unnecessary re-renders
- Use useMemo for expensive computations and useCallback for functions passed to memoized child components
- Apply virtualization (react-window or react-virtualized) for lists with more than 100 items
- Leverage React 18 Concurrent features: useTransition for non-urgent updates, useDeferredValue for expensive renders
- Implement code splitting with React.lazy and Suspense at route boundaries and heavy component boundaries
- Preload critical routes and components on user interaction (hover, focus) to reduce perceived load time
- Monitor Core Web Vitals in production: LCP < 2.5s, FID < 100ms, CLS < 0.1
- Configure Webpack splitChunks to separate vendor bundles and common code for optimal caching
- Implement proper cleanup in useEffect hooks to prevent memory leaks from event listeners and subscriptions
- Use Intersection Observer for infinite scrolling instead of scroll event listeners
- Optimize images with next/image or similar solutions with priority flag for LCP elements
- Debounce expensive operations triggered by user input to reduce computation load
- Track component mount times and re-render frequencies in production for regression detection
- Use Performance Observer API to monitor LCP, FID, and CLS in real user environments

## Advanced React Performance Patterns

### Concurrent React Features
```typescript
import { startTransition, useDeferredValue, useTransition } from 'react';

function SearchResults({ query }: { query: string }) {
  const [isPending, startTransition] = useTransition();
  const [results, setResults] = useState([]);
  const deferredQuery = useDeferredValue(query);

  const searchHandler = (newQuery: string) => {
    startTransition(() => {
      setResults(performExpensiveSearch(newQuery));
    });
  };

  return (
    <div>
      <SearchInput onChange={searchHandler} />
      {isPending && <SearchSpinner />}
      <ResultsList 
        results={results} 
        query={deferredQuery}
      />
    </div>
  );
}
```

### Advanced Memoization Strategies
```typescript
import { memo, useMemo } from 'react';
import { isEqual } from 'lodash';

const ExpensiveComponent = memo(({ data, config }) => {
  const processedData = useMemo(() => {
    return data
      .filter(item => item.active)
      .map(item => processComplexCalculation(item, config))
      .sort((a, b) => b.priority - a.priority);
  }, [data, config]);

  const chartConfig = useMemo(() => ({
    responsive: true,
    plugins: {
      legend: { display: config.showLegend },
      tooltip: { enabled: config.showTooltips }
    }
  }), [config.showLegend, config.showTooltips]);

  return <Chart data={processedData} options={chartConfig} />;
}, (prevProps, nextProps) => {
  return isEqual(prevProps.data, nextProps.data) && 
         isEqual(prevProps.config, nextProps.config);
});
```

### Virtualization for Large Lists
```typescript
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }: { items: any[] }) => {
  const Row = ({ index, style }: { index: number; style: any }) => (
    <div style={style}>
      <ItemComponent item={items[index]} />
    </div>
  );

  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  );
};

const useInfiniteScroll = (callback: () => void) => {
  const observer = useRef<IntersectionObserver>();
  
  const lastElementRef = useCallback((node: HTMLDivElement) => {
    if (observer.current) observer.current.disconnect();
    observer.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) callback();
    });
    if (node) observer.current.observe(node);
  }, [callback]);

  return lastElementRef;
};
```

## Bundle Optimization

### Advanced Code Splitting
```typescript
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => 
  import('./Dashboard').then(module => ({ default: module.Dashboard }))
);

const Analytics = lazy(() => 
  import(/* webpackChunkName: "analytics" */ './Analytics')
);

const preloadDashboard = () => import('./Dashboard');
const preloadAnalytics = () => import('./Analytics');

const LazyChart = lazy(() => 
  import('react-chartjs-2').then(module => ({ 
    default: module.Chart 
  }))
);

export function App() {
  useEffect(() => {
    setTimeout(preloadDashboard, 2000);
    
    const handleMouseEnter = () => preloadAnalytics();
    document.getElementById('analytics-link')
      ?.addEventListener('mouseenter', handleMouseEnter);
    
    return () => {
      document.getElementById('analytics-link')
        ?.removeEventListener('mouseenter', handleMouseEnter);
    };
  }, []);

  return (
    <Suspense fallback={<PageSkeleton />}>
      <Router />
    </Suspense>
  );
}
```

### Bundle Analysis Configuration
```javascript
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ],
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
          reuseExistingChunk: true
        },
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

## Core Web Vitals Optimization

### Largest Contentful Paint (LCP) Optimization
```typescript
import Image from 'next/image';

const OptimizedHero = () => (
  <Image
    src="/hero-image.jpg"
    alt="Hero"
    width={1200}
    height={600}
    priority
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ..."
  />
);

export function Head() {
  return (
    <>
      <link rel="preconnect" href="https://fonts.googleapis.com" />
      <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
      <link rel="preload" href="/critical.css" as="style" />
      <link rel="preload" href="/hero-image.jpg" as="image" />
    </>
  );
}
```

### First Input Delay (FID) Optimization
```typescript
const heavyLibrary = lazy(() => import('heavy-library'));

import { unstable_scheduleCallback, unstable_NormalPriority } from 'scheduler';

const deferNonCriticalWork = (callback: () => void) => {
  unstable_scheduleCallback(unstable_NormalPriority, callback);
};

const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
};
```

### Cumulative Layout Shift (CLS) Prevention
```css
.skeleton-container {
  min-height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.aspect-ratio-container {
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 56.25%;
}

.aspect-ratio-content {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```

```typescript
const StableComponent = ({ isLoading, data }: { isLoading: boolean; data?: any }) => {
  return (
    <div className="stable-container" style={{ minHeight: '200px' }}>
      {isLoading ? (
        <div className="skeleton" style={{ height: '200px' }} />
      ) : (
        <div className="content" style={{ height: 'auto' }}>
          {data && <DataVisualization data={data} />}
        </div>
      )}
    </div>
  );
};
```

## Performance Monitoring

### Real-time Performance Tracking
```typescript
const observePerformance = () => {
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'largest-contentful-paint') {
        trackMetric('LCP', entry.startTime);
      }
      if (entry.name === 'first-input') {
        trackMetric('FID', entry.processingStart - entry.startTime);
      }
      if (entry.name === 'layout-shift') {
        trackMetric('CLS', entry.value);
      }
    }
  });

  observer.observe({ entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'] });
};

const usePerformanceMonitor = () => {
  useEffect(() => {
    const startTime = performance.now();
    
    return () => {
      const duration = performance.now() - startTime;
      trackMetric('component-mount-time', duration);
    };
  }, []);
};
```

### Memory Leak Detection
```typescript
const useCleanup = (effect: () => () => void, deps: any[]) => {
  useEffect(() => {
    const cleanup = effect();
    return () => {
      cleanup();
      if (typeof cleanup === 'function') {
        cleanup();
      }
    };
  }, deps);
};

const useEventListener = (eventName: string, handler: (event: Event) => void) => {
  const savedHandler = useRef(handler);

  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    const eventListener = (event: Event) => savedHandler.current(event);
    window.addEventListener(eventName, eventListener);
    
    return () => {
      window.removeEventListener(eventName, eventListener);
    };
  }, [eventName]);
};
```

## Performance Analysis Tools

### Custom Performance Profiler
```typescript
import { Profiler } from 'react';

const onRenderCallback = (id: string, phase: 'mount' | 'update', actualDuration: number) => {
  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration);
  
  fetch('/api/performance', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      componentId: id,
      phase,
      duration: actualDuration,
      timestamp: Date.now()
    })
  });
};

export const ProfiledComponent = ({ children }: { children: React.ReactNode }) => (
  <Profiler id="ProfiledComponent" onRender={onRenderCallback}>
    {children}
  </Profiler>
);
```

## Examples

<example>
  User: "My React app is slow when scrolling through a list of 1000 items. How can I optimize this?"
  
  Response: Implement virtualization with react-window to render only visible items:
  
  ```typescript
  import { FixedSizeList as List } from 'react-window';
  
  const VirtualizedList = ({ items }) => {
    const Row = ({ index, style }) => (
      <div style={style}>
        <ItemComponent item={items[index]} />
      </div>
    );
  
    return (
      <List
        height={600}
        itemCount={items.length}
        itemSize={50}
        width="100%"
      >
        {Row}
      </List>
    );
  };
  ```
  
  This reduces DOM nodes from 1000+ to ~12 visible items, dramatically improving scroll performance.
  
  Before: 1000 DOM nodes, janky scrolling
  After: ~12 DOM nodes, smooth 60fps scrolling
</example>

<example type="invalid">
  User: "My React app is slow when scrolling through a list of 1000 items."
  
  Response: "Try optimizing your components with React.memo."
  
  Reasoning: This response fails to identify the core issue (rendering too many DOM nodes), doesn't provide the appropriate solution (virtualization), lacks concrete code examples, and misses the opportunity to explain measurable performance improvements. React.memo won't solve the fundamental problem of rendering 1000+ items in the DOM.
</example>
